{
  "index": 1478,
  "question": "You are a code expert. Please use your professional knowledge to generate accurate and professional responses. Make sure the code you generate is executable and functional. Implement an SSH terminal using tauri+vue3+xterm.",
  "checklist": [
    {
      "id": 0,
      "title": "Is the SSH terminal functionality properly implemented?",
      "description": "Check whether the code correctly implements SSH connection handling using appropriate libraries like `node-ssh` or `ssh2` in Tauri's Rust backend. Verify the implementation includes authentication methods (password, key-based), session management, and terminal command execution. Score 0 if SSH connection is not implemented, 5 if basic connection works but lacks robust error handling, and 10 if full SSH protocol support is provided with proper security measures.",
      "maxScore": 10
    },
    {
      "id": 1,
      "title": "Is xterm.js properly integrated with Vue3?",
      "description": "Evaluate the integration of xterm.js within the Vue3 component system. Check for proper lifecycle management (mounting/unmounting), event handling, and reactive data binding. The terminal should be properly sized, support text selection, copying, and pasting. Deduct 5 points if the terminal doesn't resize with its container, 3 points if clipboard integration is missing, and 2 points if terminal colors/themes aren't configurable. The full score is 10 points.",
      "maxScore": 10
    },
    {
      "id": 2,
      "title": "Is the Tauri backend properly configured and connected with the Vue frontend?",
      "description": "Review the implementation of IPC between Tauri's Rust backend and the Vue3 frontend. Check for proper command registration, event handling, and data serialization. Verify that the application properly handles permissions for file system access and network connections. Deduct 5 points if the IPC mechanism is insecure, 3 points if the permission model is too permissive, and 5 points if there's no error handling for backend operations. The full score is 10 points.",
      "maxScore": 10
    },
    {
      "id": 3,
      "title": "Does the terminal support essential features like session persistence and reconnection?",
      "description": "Assess whether the application supports saving connection profiles, reconnecting to previous sessions, and handling connection drops gracefully. Check for the implementation of terminal session persistence across application restarts. Deduct 5 points if connection profiles cannot be saved, 5 points if there's no automatic reconnection logic, and 3 points if terminal history/buffer isn't preserved between sessions. The full score is 10 points.",
      "maxScore": 10
    },
    {
      "id": 4,
      "title": "Is the code robust?",
      "description": "Evaluate whether the code can handle common abnormal situations (such as network timeouts, authentication failures, sudden disconnections, etc.) and provide friendly error prompts or recovery mechanisms. Code with strong robustness should be able to effectively handle these edge cases, giving 10 points. If the robustness is average, give 5 points, and if no exceptions are handled, give 0 points.",
      "maxScore": 10
    },
    {
      "id": 5,
      "title": "Are there any innovative features that are eye-catching?",
      "description": "Check whether the code includes surprise features that enhance the experience (e.g., 1. Split-screen terminal support 2. Command history with search 3. Integrated SFTP file browser 4. Terminal session recording/playback). Add 3 points for each practical innovative feature implemented (maximum 10 points).",
      "maxScore": 10
    },
    {
      "id": 6,
      "title": "Are there any redundant features?",
      "description": "Strictly check three types of redundancy: 1. Redundant implementation of similar functions (e.g., multiple terminal emulation libraries used together) 2. Function modules unrelated to SSH terminals (e.g., a built-in game) 3. Fancy effects that affect terminal performance (e.g., excessive animations). Deduct 3 points for each redundancy found, and directly deduct 10 points if the core terminal functions are interfered with by redundant code.",
      "maxScore": 10
    },
    {
      "id": 7,
      "title": "Does the code have engineering quality?",
      "description": "Review modular design (such as separating SSH logic/terminal view/state management), unit test coverage, and build process automation. Deduct 5 points if global state pollution is found or design patterns are not used; deduct 5 points if the code duplication rate is too high (over 30%); deduct 5 points if the build process is not automated. The full score is 10 points.",
      "maxScore": 10
    },
    {
      "id": 8,
      "title": "Does the interface vision meet professional design standards?",
      "description": "Evaluate whether the overall design follows modern terminal design principles: 1) Consistent color scheme with good contrast for terminal text 2) Proper spacing around the terminal and control elements 3) Professional monospace font selection with appropriate sizing. Deduct 3 points for cramped UI elements, 5 points for poor contrast that affects readability, and 5 points for inconsistent spacing between UI components. The full score is 10 points.",
      "maxScore": 10
    },
    {
      "id": 9,
      "title": "Is the dynamic interaction smooth and seamless?",
      "description": "Judge whether the terminal performance and interaction conform to user expectations: 1) Terminal input latency â‰¤ 50ms 2) Smooth scrolling of terminal output 3) Responsive UI controls for settings/connections. Deduct 5 points for noticeable input lag, 3 points for jerky scrolling with large outputs, and 5 points for unresponsive UI during active SSH sessions. The full score is 10 points.",
      "maxScore": 10
    }
  ],
  "class": "Utility Tools-Automation",
  "difficulty": "hard"
}