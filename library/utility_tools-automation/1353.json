{
  "index": 1353,
  "question": "You are a code expert. Please use your professional knowledge to generate accurate and professional responses. Make sure that the generated code is executable for demonstration. Generate Avalonia axaml page code, control code, and view models dynamically based on table names, table fields, field classes, field control types, field visibility, field default values, etc. Use reflection to dynamically create properties and add them to the view model at runtime.",
  "checklist": [
    {
      "id": 0,
      "title": "Is the dynamic AXAML generation system fully implemented?",
      "description": "Review whether the code correctly generates Avalonia AXAML based on table metadata. Check if it handles different layout types (Grid, StackPanel, DockPanel), properly sets column definitions and row definitions, and correctly positions controls. Score 0 if dynamic AXAML generation is not implemented, 5 if basic generation works but with layout issues, and 10 if the generation system is complete with proper nesting and responsive layout.",
      "maxScore": 10
    },
    {
      "id": 1,
      "title": "Are all control types properly supported and instantiated?",
      "description": "Verify that the code can dynamically create and configure different Avalonia controls (TextBox, ComboBox, DatePicker, CheckBox, etc.) based on field types. Check if control-specific properties and behaviors are correctly set. Deduct 2 points for each unsupported common control type, and 5 points if custom control templates are missing. The full score is 10 points.",
      "maxScore": 10
    },
    {
      "id": 2,
      "title": "Is the reflection-based property system correctly implemented?",
      "description": "Evaluate whether the code uses reflection to dynamically create properties at runtime and add them to view models. Check for proper implementation of INotifyPropertyChanged, property change notifications, and type-safe property access. Deduct 5 points if dynamic property creation is not implemented, 3 points if property change notifications are missing, and 2 points if type conversion is not handled properly. The full score is 10 points.",
      "maxScore": 10
    },
    {
      "id": 3,
      "title": "Are data binding and validation mechanisms properly implemented?",
      "description": "Check if the code implements two-way data binding between the dynamically generated UI and view model properties. Verify that input validation, error reporting, and error visualization work correctly. Deduct 5 points if data binding is one-way only, 3 points if validation is missing, and 5 points if there's no visual feedback for validation errors. The full score is 10 points.",
      "maxScore": 10
    },
    {
      "id": 4,
      "title": "Is the code robust?",
      "description": "Evaluate whether the code can handle common abnormal situations (such as missing metadata, invalid field types, null references, etc.) and provide friendly error prompts or recovery mechanisms. Code with strong robustness should be able to effectively handle these edge cases, giving 10 points. If the robustness is average, give 5 points, and if no exceptions are handled, give 0 points.",
      "maxScore": 10
    },
    {
      "id": 5,
      "title": "Are there any innovative features that are eye-catching?",
      "description": "Check whether the code includes surprise features that enhance the experience (e.g., 1. Live preview of generated UI 2. Metadata editor with real-time AXAML updates 3. Theme switching for generated controls). Add 3 points for each practical innovative feature implemented (maximum 10 points).",
      "maxScore": 10
    },
    {
      "id": 6,
      "title": "Are there any redundant features?",
      "description": "Strictly check three types of redundancy: 1. Redundant implementation of similar functions (e.g., multiple reflection helper methods doing the same thing) 2. Function modules unrelated to dynamic UI generation 3. Overly complex code that could be simplified. Deduct 3 points for each redundancy found, and directly deduct 10 points if the core functions are interfered with by redundant code.",
      "maxScore": 10
    },
    {
      "id": 7,
      "title": "Does the code have engineering quality?",
      "description": "Review modular design (such as separating metadata handling/code generation/view model creation), unit test coverage, and proper error handling. Deduct 5 points if there's tight coupling between components; deduct 5 points if the code duplication rate is too high (over 30%); deduct 5 points if there's no exception handling strategy. The full score is 10 points.",
      "maxScore": 10
    },
    {
      "id": 8,
      "title": "Does the generated UI meet professional design standards?",
      "description": "Evaluate whether the generated UI follows modern design principles: 1) Proper control spacing and margins 2) Consistent form layout with aligned labels and inputs 3) Professional visual hierarchy of elements. Deduct 3 points for poor alignment of form elements, 5 points for inconsistent spacing between controls, and 5 points for poor visual hierarchy. The full score is 10 points.",
      "maxScore": 10
    },
    {
      "id": 9,
      "title": "Is the dynamic interaction smooth and responsive?",
      "description": "Judge whether the dynamic UI updates conform to good UX practices: 1) Fast property updates without UI freezing 2) Smooth transitions when showing/hiding controls 3) Responsive feedback during long operations. Deduct 5 points for UI freezes during updates, 3 points for jarring control visibility changes, and 5 points for lack of loading indicators during long operations. The full score is 10 points.",
      "maxScore": 10
    }
  ],
  "class": "Utility Tools-Automation",
  "difficulty": "hard"
}